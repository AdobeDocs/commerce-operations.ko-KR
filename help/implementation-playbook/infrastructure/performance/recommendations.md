---
title: 성능 최적화 Recommendations
description: 다음 권장 사항에 따라 Adobe Commerce 구현의 성능을 최적화합니다.
exl-id: c5d62e23-be43-4eea-afdb-bb1b156848f9
source-git-commit: 821ef18c1b0f00a6b9574be968ad76f0c230335c
workflow-type: tm+mt
source-wordcount: '1290'
ht-degree: 0%

---

# 성능 최적화 검토

성능 최적화는 여러 측면에서 제공될 수 있지만 대부분의 시나리오에서 고려해야 하는 몇 가지 일반적인 권장 사항이 있습니다. 여기에는 인프라 요소에 대한 구성 최적화, Adobe Commerce 백엔드 구성 및 아키텍처 확장성 계획이 포함됩니다.

## 인프라

다음 섹션에서는 인프라 최적화를 위한 권장 사항에 대해 설명합니다.

### DNS 조회

DNS 조회는 도메인 이름이 속한 IP 주소를 찾는 프로세스입니다. 브라우저는 DNS 조회가 완료될 때까지 기다렸다가 각 요청에 대한 내용을 다운로드해야 합니다. 전반적인 페이지 로드 시간을 향상하기 위해서는 DNS 조회 수를 줄이는 것이 중요합니다.

### CDN(콘텐츠 전달 네트워크)

CDN을 사용하여 자산 다운로드 성능을 최적화합니다. Adobe Commerce은 Fastly를 사용합니다. Adobe Commerce의 온-프레미스 구현이 있는 경우 CDN 계층을 추가하는 것도 고려해야 합니다.

### 웹 지연

데이터 센터의 위치는 프론트엔드 사용자의 웹 지연에 영향을 줍니다.

### 네트워크 대역폭

충분한 네트워크 대역폭은 웹 노드, 데이터베이스, 캐싱/세션 서버 및 기타 서비스 간의 데이터 교환을 위한 주요 요구 사항 중 하나입니다.

Adobe Commerce은 캐싱을 효과적으로 활용하여 고성능을 발휘하므로 시스템이 Redis와 같은 캐싱 서버와 데이터를 능동적으로 교환할 수 있습니다. Redis가 원격 서버에 있는 경우 읽기/쓰기 작업에서 병목 현상을 방지하기 위해 웹 노드와 캐싱 서버 사이에 충분한 네트워크 채널을 제공해야 합니다.

### 운영 체제(OS)

운영 체제 구성 및 최적화는 다른 고부하 웹 애플리케이션과 비교할 때 Adobe Commerce에 대해 유사합니다. 서버가 처리하는 동시 연결 수가 증가하면 사용 가능한 소켓 수가 완전히 할당될 수 있습니다.

### 웹 노드의 CPU

하나의 CPU 코어는 캐시 없이 약 2~4개의 Adobe Commerce 요청을 효과적으로 처리할 수 있습니다. 모든 들어오는 요청을 대기열에 넣지 않고 처리하는 데 필요한 웹 노드/코어 수를 결정하려면 다음 식을 사용합니다.

```
N[Cores] = (N [Expected Requests] / 2) + N [Expected Cron Processes])
```

### PHP-FPM 설정

이러한 설정을 최적화하는 것은 다양한 프로젝트에 대한 성능 테스트 결과에 따라 다릅니다.

- **바이트 코드**- PHP 7에서 Adobe Commerce의 최대 속도를 얻으려면 다음을 활성화해야 합니다. `opcache` 모듈을 지정하고 올바로 구성합니다.

- **APCU**—PHP APCu 확장을 활성화하고 최대 성능을 최적화하도록 Composer를 구성하는 것이 좋습니다. 이 확장은 열린 파일의 파일 위치를 캐시하므로 페이지, Ajax 호출 및 끝점을 비롯한 Adobe Commerce 서버 호출의 성능이 향상됩니다.

- **Realpath_cacheconfiguration**- 최적화 `realpath_cache` 에서는 PHP 프로세스가 페이지를 로드할 때마다 경로를 조회하는 대신 파일에 경로를 캐시할 수 있습니다.

### 웹 서버

nginx를 웹 서버로 사용하려면 약간의 재구성만 필요합니다. Nginx 웹 서버는 더 나은 성능을 제공하며 Adobe Commerce의 샘플 구성 파일을 사용하여 쉽게 구성할 수 있습니다([`nginx.conf.sample`](https://github.com/magento/magento2/blob/2.4/nginx.conf.sample)).

- TCP로 PHP-FPM 설정

- HTTP/2 및 Gzip 활성화

- 작업자 연결 최적화

### 데이터베이스

각 저장소 및 환경이 다르기 때문에 이 문서에서는 심층적인 MySQL 튜닝 지침을 제공하지는 않지만 몇 가지 일반적인 권장 사항을 제공할 수 있습니다.

Adobe Commerce 데이터베이스(및 기타 데이터베이스)는 데이터 및 인덱스를 저장하는 데 사용할 수 있는 메모리 양에 따라 다릅니다. MySQL 데이터 인덱싱을 효과적으로 활용하려면 사용 가능한 메모리 양이 데이터베이스에 저장된 데이터 크기의 절반 가까워야 합니다.

최적화 `innodb_buffer_pool_instances` 동일한 인스턴스에 액세스하려는 여러 스레드의 문제를 방지하기 위해 를 설정합니다. 값 `max_connections` 매개 변수는 응용 프로그램 서버에 구성된 총 PHP 스레드 수와 상호 연관되어야 합니다. 다음 공식을 사용하여 다음에 대한 최상의 값을 계산합니다. `innodb-thread-concurrency`:

```
innodb-thread-concurrency = 2 * (NumCPUs+NumDisks)
```

### 세션 캐싱

세션 캐싱은 별도의 Redis 인스턴스에 대해 구성하는 데 좋은 후보입니다. 이 캐시 유형에 대한 메모리 구성은 사이트의 장바구니 포기 전략과 세션이 캐시에 남아 있을 것으로 예상하는 시간을 고려해야 합니다.

Redis에는 최적의 성능을 위해 다른 모든 캐시를 메모리에 보유하기 위해 충분한 메모리가 할당되어야 합니다. 블록 캐시는 구성할 메모리의 양을 결정하는 중요한 요소입니다. 블록 캐시는 사이트의 페이지 수(SKU 수 x 스토어 보기 수)에 따라 증가합니다.

### 페이지 캐싱

Adobe Commerce 스토어의 전체 페이지 캐시에 Varnish를 사용하는 것이 좋습니다. 다음 `PageCache` 모듈이 코드 베이스에 여전히 있지만 개발 목적으로만 사용해야 합니다.

웹 계층 앞에 있는 별도의 서버에 Vannish를 설치합니다. 모든 수신 요청을 수락하고 캐시된 페이지 복사본을 제공해야 합니다. Varnish가 보안 페이지에서 효과적으로 작동할 수 있도록 하기 위해 SSL 종료 프록시를 Varnish 앞에 배치할 수 있습니다. Nginx를 이 용도로 사용할 수 있습니다.

Varnish 전체 페이지 캐시 메모리 무효화가 효과적이지만 가장 인기 있는 페이지를 메모리에 보관하기 위해 Varnish에 충분한 메모리를 할당하는 것이 좋습니다.

### 메시지 큐

MQF(메시지 대기열 프레임워크)는 모듈이 메시지를 대기열에 게시할 수 있도록 하는 시스템입니다. 또한 비동기적으로 메시지를 수신하는 소비자도 정의합니다. Adobe Commerce 지원 [!DNL RabbitMQ] 는 메시지를 보내고 받는 확장 가능한 플랫폼을 제공하는 메시징 브로커입니다.

### 성능 테스트 및 모니터링

각 프로덕션 릴리스 이전의 성능 테스트는 항상 전자 상거래 플랫폼의 성능을 추정하는 데 권장됩니다. 출시 후 모니터링을 유지하고 피크 타임에 대처할 수 있는 확장성 및 백업 계획을 수립합니다.

>[!NOTE]
>
> 클라우드 인프라의 Adobe Commerce은 이미 위의 인프라 및 아키텍처 최적화를 모두 적용하지만, DNS 조회는 범위를 벗어납니다.

### 검색 {#search-heading}

Adobe Commerce 버전 2.4부터는 Elasticsearch(또는 OpenSearch)가 필요하지만, 2.4 이전 버전에서는 활성화하는 것이 좋습니다.

## 운영 모델

앞서 언급한 일반적인 인프라 최적화 권장 사항과 별도로 특정 비즈니스 모드 및 규모에 맞는 성능을 향상시키는 접근 방식도 있습니다. 각 시나리오가 다르기 때문에 이 문서에서는 모든 시나리오에 대한 심층적인 조정 지침을 제공하지는 않지만, 참조에 대한 몇 가지 고급 옵션을 제공할 수 있습니다.

### 헤드리스 아키텍처

세부 사항을 설명하는 별도의 섹션이 있습니다. [headless](../../architecture/headless/adobe-commerce.md) 및 다른 옵션입니다. 요약하면, 플랫폼 자체와 상점 계층을 분리합니다. 여전히 동일한 백엔드이지만 Adobe Commerce은 더 이상 요청을 직접 처리하지 않고 대신 GraphQL API를 통해 사용자 지정 상점 만 지원합니다.

### Adobe Commerce 업데이트 유지

Adobe Commerce은 최신 버전을 실행할 때 항상 성능이 향상됩니다. 각 새 버전이 릴리스된 후 Adobe Commerce을 최신 상태로 유지할 수 없더라도 [업그레이드](../../../upgrade/overview.md) Adobe Commerce에서 상당한 성능 최적화를 도입한 경우.

예를 들어, 2020년에 Adobe은 Redis에 대한 최적화를 발표하여 많은 비효율성, 연결 문제, Redis와 Adobe Commerce 간의 불필요한 데이터 전송을 해결했습니다. 2.3과 2.4 사이의 전반적인 성능은 밤낮이며 Redis 최적화로 인해 장바구니, 체크아웃, 동시 사용자가 크게 개선되었습니다.

### 데이터 모델 최적화

잘못된 데이터 모델, 제대로 구조화되지 않은 데이터, 색인이 없는 데이터 등 데이터에서 많은 문제가 발생합니다.

몇 개의 연결을 테스트하는 경우에는 괜찮아 보이지만 실제 트래픽이 발생할 때 프로덕션에서 볼 수 있는 느림이 발생하는 부분입니다. 시스템 통합자는 데이터 모델(특히 제품 속성)을 디자인하고 불필요한 속성을 추가하지 않으며 비즈니스 논리에 영향을 주는 필수 속성(예: 가격 책정, 재고 가용성 및 검색)을 유지하는 방법을 아는 것이 매우 중요합니다.

비즈니스 논리에 영향을 주지 않지만 상점 앞에 존재해야 하는 속성의 경우 이를 몇 가지 속성(예: JSON 형식)으로 결합하십시오.

플랫폼 성능을 최적화하기 위해 PIM 또는 ERP에서 가져온 데이터 또는 속성에서 상점 앞에 비즈니스 논리가 필요하지 않은 경우 해당 속성을 Adobe Commerce에 추가할 필요가 없습니다.

### 확장성을 위한 설계

이는 캠페인을 실행하고 피크 타임에 자주 직면하는 비즈니스에 중요합니다. 아키텍처 및 애플리케이션 설계를 쉽게 확장할 수 있도록 피크 타임에는 리소스를 늘리고 그 이후에는 리소스를 줄일 수 있습니다.
